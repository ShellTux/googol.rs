//! Implements the `BarrelService` gRPC server for managing web page indexing and search.
//!
//! The `Barrel` struct handles incoming gRPC requests for:
//! - Retrieving backlinks and outlinks
//! - Indexing new pages
//! - Performing search queries
//! - Checking server health and status
//!
//! This module requires async_trait for asynchronous trait methods.
//!
//! Example:
//!
//! ```rust
//! use tonic::transport::Server;
//! use googol::{barrel::Barrel, proto::barrel_service_server::BarrelServiceServer, settings::barrel::BarrelConfig};
//!
//! #[tokio::main]
//! async fn main() -> Result<(), Box<dyn std::error::Error>> {
//!     let config = BarrelConfig {
//!         address: "127.0.0.1:44992".parse().unwrap(),
//!         filepath: ".barrel-data.json".to_string(),
//!     };
//!     let barrel = Barrel::new(&config).await;
//!     // Server::builder()
//!     //     .add_service(BarrelServiceServer::new(barrel))
//!     //     .serve(config.address)
//!     //     .await?;
//!     Ok(())
//! }
//! ```

use crate::{
    GoogolStatus,
    address::Address,
    index_store::IndexStore,
    page::Page,
    proto::{
        BacklinksRequest, BacklinksResponse, BarrelStatusRequest, BarrelStatusResponse,
        HealthRequest, HealthResponse, IndexRequest, IndexResponse, OutlinksRequest,
        OutlinksResponse, SearchRequest, SearchResponse, barrel_service_server::BarrelService,
    },
    settings::barrel::BarrelConfig,
};
use log::{debug, error};
use tokio::sync::Mutex as AsyncMutex;
use tonic::{Request, Response, Status};
use url::Url;

/// Represents a Barrel server instance.
///
/// This struct manages the internal index store and handles incoming requests
/// for various barrel operations.
#[derive(Debug, Default)]
pub struct Barrel {
    /// The address of this Barrel instance.
    pub address: Address,
    /// The internal index store. Protected by a mutex for concurrent access.
    index: AsyncMutex<IndexStore>,
}

impl Barrel {
    /// Creates a new `Barrel` instance from the provided `BarrelConfig`.
    ///
    /// This asynchronous function initializes the `Barrel`'s internal index store by
    /// loading data from the file specified in the configuration.
    ///
    /// # Arguments
    ///
    /// * `config` - A reference to a `BarrelConfig` containing the configuration parameters,
    ///   including the address and filepath for loading the index store.
    ///
    /// # Returns
    ///
    /// A `Future` that resolves to a `Barrel` instance with the index store loaded.
    ///
    /// # Example
    ///
    /// ```rust
    /// use googol::{barrel::Barrel, settings::barrel::BarrelConfig};
    ///
    /// let config = BarrelConfig {
    ///     address: "127.0.0.1:8080".parse().unwrap(),
    ///     filepath: "path/to/index/file".to_string(),
    /// };
    /// let barrel = Barrel::new(&config);
    /// ```
    pub async fn new(config: &BarrelConfig) -> Self {
        Self {
            address: Address::new(config.address),
            index: AsyncMutex::new(IndexStore::load(&config.filepath).unwrap()),
        }
    }
}

/// Implements the `BarrelService` gRPC service trait for the `Barrel` struct.
///
/// This trait is generated by `tonic` based on the `BarrelService` definition
/// in `googol.proto` file. It provides asynchronous methods corresponding
/// to the RPCs defined in that service, allowing `Barrel` to handle incoming
/// gRPC requests.
///
/// Each method handles a specific RPC call:
/// - `consult_backlinks`: Retrieves backlinks for a given URL.
/// - `consult_outlinks`: Retrieves outlinks for a given URL.
/// - `health`: Checks the health status of the server.
/// - `index`: Indexes a new page with associated words and outlinks.
/// - `search`: Searches the index for pages matching given words.
/// - `status`: Provides the current status of the Barrel server.
///
/// # Requirements
///
/// The `Barrel` struct must implement this trait to serve as a gRPC server
/// handling requests for the defined service.
///
/// # Example
///
/// ```rust
/// use tonic::transport::Server;
/// use googol::{
///     barrel::Barrel,
///     proto::barrel_service_server::BarrelServiceServer,
///     settings::barrel::BarrelConfig,
/// };
///
/// #[tokio::main]
/// async fn main() -> Result<(), Box<dyn std::error::Error>> {
///     let settings = BarrelConfig {
///         address: "127.0.0.1:44992".parse().unwrap(),
///         filepath: ".barrel-data.json".to_string(),
///     };
///
///     let barrel = Barrel::new(&settings).await;
///
///     // Server::builder()
///     //     .add_service(BarrelServiceServer::new(barrel))
///     //     .serve(settings.address)
///     //     .await?;
///
///     Ok(())
/// }
/// ```
///
/// # Note
///
/// Implementing this trait requires the `async_trait` attribute, which `tonic`
/// uses internally to allow asynchronous method definitions in traits.
#[tonic::async_trait]
impl BarrelService for Barrel {
    /// Handles a `consult_backlinks` gRPC request.
    ///
    /// Retrieves backlinks for the URL specified in the request.
    ///
    /// # Arguments
    ///
    /// * `request` - The gRPC request containing the URL to query.
    ///
    /// # Returns
    ///
    /// A `Result` wrapping a `Response<BacklinksResponse>` containing the backlinks and status.
    async fn consult_backlinks(
        &self,
        request: Request<BacklinksRequest>,
    ) -> Result<Response<BacklinksResponse>, Status> {
        debug!("{:#?}", request);

        let request = request.into_inner();

        let url = Url::parse(&request.url).map_err(|e| {
            error!("Invalid URL provided: {}", e);
            Status::invalid_argument(format!("Invalid URL: {}", request.url))
        })?;

        let backlinks = self
            .index
            .lock()
            .await
            .consult_backlinks(&url)
            .iter()
            .map(|url| url.to_string())
            .collect();

        let status = GoogolStatus::Success as i32;

        Ok(Response::new(BacklinksResponse { status, backlinks }))
    }

    /// Handles an `consult_outlinks` gRPC request.
    ///
    /// Retrieves outlinks for the URL specified in the request.
    ///
    /// # Arguments
    ///
    /// * `request` - The gRPC request containing the URL to query.
    ///
    /// # Returns
    ///
    /// A `Result` wrapping a `Response<OutlinksResponse>` containing the outlinks and status.
    async fn consult_outlinks(
        &self,
        request: Request<OutlinksRequest>,
    ) -> Result<Response<OutlinksResponse>, Status> {
        debug!("{:#?}", request);

        let request = request.into_inner();

        let url = Url::parse(&request.url).map_err(|e| {
            error!("Invalid URL provided: {}", e);
            Status::invalid_argument(format!("Invalid URL: {}", request.url))
        })?;

        let outlinks = self
            .index
            .lock()
            .await
            .consult_outlinks(&url)
            .iter()
            .map(|url| url.to_string())
            .collect();
        debug!("outlinks = {:?}", outlinks);
        let status = GoogolStatus::Success as i32;

        Ok(Response::new(OutlinksResponse { status, outlinks }))
    }

    /// Handles a `health` gRPC request.
    ///
    /// Checks the health status of the server.
    ///
    /// # Arguments
    ///
    /// * `request` - The gRPC health check request.
    ///
    /// # Returns
    ///
    /// A `Response<HealthResponse>` indicating server status.
    async fn health(
        &self,
        request: Request<HealthRequest>,
    ) -> Result<Response<HealthResponse>, Status> {
        debug!("{:#?}", request);

        Ok(Response::new(HealthResponse {
            status: format!("OK: Online. Listening at {}...", self.address),
        }))
    }

    /// Handles an `index` gRPC request.
    ///
    /// Indexes a new page with associated words and outlinks.
    ///
    /// # Arguments
    ///
    /// * `request` - The gRPC request containing page data to index.
    ///
    /// # Returns
    ///
    /// A `Response<IndexResponse>` indicating the result of the indexing operation.
    async fn index(
        &self,
        request: Request<IndexRequest>,
    ) -> Result<Response<IndexResponse>, Status> {
        debug!("{:#?}", request);

        let request = request.into_inner();

        let index = request.index.unwrap();

        let page = Page::from(index.page.unwrap());

        let words = index.words;

        let outlinks: Vec<Url> = index
            .outlinks
            .iter()
            .filter_map(|url| match Url::parse(url) {
                Ok(url) => Some(url),
                Err(e) => {
                    error!("Invalid url `{}`: {}", url, e);
                    None
                }
            })
            .collect();

        let mut index = self.index.lock().await;

        index.store(&page, &words, &outlinks);
        index.save().unwrap();

        Ok(Response::new(IndexResponse { size_bytes: 0 }))
    }

    /// Handles a `search` gRPC request.
    ///
    /// Searches the index for pages matching the provided words.
    ///
    /// # Arguments
    ///
    /// * `request` - The gRPC request containing search terms.
    ///
    /// # Returns
    ///
    /// A `Response<SearchResponse>` with the matching pages.
    async fn search(
        &self,
        request: Request<SearchRequest>,
    ) -> Result<Response<SearchResponse>, Status> {
        debug!("{:#?}", request);

        let request = request.into_inner();

        let index = self.index.lock().await;

        let words = request.words;

        let pages = index
            .search_by_relevance(&words)
            .iter()
            .cloned()
            .map(|page| page.into())
            .collect();

        Ok(Response::new(SearchResponse {
            status: GoogolStatus::Success as i32,
            pages,
        }))
    }

    /// Handles a `status` gRPC request.
    ///
    /// Provides the current status of the Barrel server.
    ///
    /// # Arguments
    ///
    /// * `request` - The gRPC request for status.
    ///
    /// # Returns
    ///
    /// A `Response<BarrelStatusResponse>` with the server's status information.
    async fn status(
        &self,
        request: Request<BarrelStatusRequest>,
    ) -> Result<Response<BarrelStatusResponse>, Status> {
        debug!("{:#?}", request);

        let status = String::default();

        Ok(Response::new(BarrelStatusResponse { status }))
    }
}
